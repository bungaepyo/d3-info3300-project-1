<html>

<head>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <style>
        * {
            font-family: Arial;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            width: 800px;
        }

        .legend div {
            margin: 5px;
            color: white;
            padding: 10px;
        }

        .gridlines line {
            stroke: #bbb;
        }

        .gridlines .domain {
            stroke: none;

        }
    </style>
</head>

<body>
    <div class="graph-1">
        <h2>Graph #1</h2>
        <svg id="alt_fuel_stations" height="600" width="900"></svg>
    </div>
    <div class="graph-2">
        <h2>Top Speed V.S Range by Brand</h2>
        <svg id="scatterplot" height="600" width="900">

            <text id="label" x="590" y="5" text-anchor="end" alignment-baseline="hanging"></text>
            <text x="100" y="260" transform="rotate(-90 40 290)" text-anchor="end" alignment-baseline="hanging">Range
                (km)</text>
            <text x="530" y="580" text-anchor="end" alignment-baseline="hanging">Top Speed (km/h)</text>
        </svg>

        <div id="scatterLegend" class="legend"></div>
    </div>
</body>




<script class="graph-1-script">
    const svg = d3.select("#alt_fuel_stations");
    const width = svg.attr("width");
    const height = svg.attr("height");
    const margins = {top: 30, right: 30, bottom: 50, left: 50};
    const plotWidth = width - margins.left - margins.right;
    const plotHeight = height - margins.top - margins.bottom;

    let annotation = svg.append("g").attr("id","annotations");
    let plotArea = svg.append("g").attr("transform",`translate(${margins.left},${margins.top})`);

    d3.csv("alt_fuel_stations.csv").then(data => {
        
        // Filter out datapoints without open date
        data = data.filter((d) => d['Open Date'] !== "");


        const timeParser = d3.timeParse('%Y-%m-%d');
        let openYear = [];

        data.forEach(d => {
            //Parse "Open Date" and get "Open Year"

            let date = timeParser(d["Open Date"]);
            d['Open Year'] = date.getFullYear();

            // Store open information by year
            if (!openYear.some(e => e.Year == d['Open Year'])) {
                openYear.push({
                    "Year": d['Open Year'],
                    "Count": 1
                })
            } else {
                openYear.find(e => e.Year == d['Open Year']).Count++;
            }
        });
        
        // Filter out 2021 because the statistics for this year is not complete
        openYear = openYear.filter((d) => d['Year'].toString() !== "2021")

        // Sort openYear in order of time
        openYear.sort(function(year1,year2) {
            return year2.Year - year1.Year
        });
        
        // Extents & Scales
        const countExtent = d3.extent(openYear, d => d['Count']);
        const countScale = d3.scaleLinear().domain(countExtent).range([plotHeight, 0]);
        
        const yearExtent = d3.extent(openYear, d => d['Year']);
        const yearScale = d3.scaleLinear().domain(yearExtent).range([0,plotWidth]);
        
        // Y axis & Gridlines
        let leftAxis = d3.axisLeft(countScale)
        let leftGridlines = d3.axisLeft(countScale)
                              .tickSize(-plotWidth-10)
                              .tickFormat("")
        annotation.append("g")
            .attr("class", "y axis")
            .attr("transform",`translate(${margins.left-10},${margins.top})`)
            .call(leftAxis)
        annotation.append("g")
            .attr("class", "y gridlines")
            .attr("transform",`translate(${margins.left},${margins.top})`)
            .call(leftGridlines);
        
        // X axis & Gridlines
        let bottomAxis = d3.axisBottom(yearScale).tickFormat(d3.format("d"));

        annotation.append("g")
            .attr("class", "x axis")
            .attr("transform",`translate(${margins.left},${plotHeight+margins.top+10})`)
            .call(bottomAxis);

        // Initiate a line generator
        var lineGen = d3.line()
                  .x( d => yearScale(d['Year']) )
                  .y( d => countScale(d['Count']) )
                  .curve(d3.curveMonotoneX);
        
        // Add lines
        plotArea.append("path")
                .datum(openYear)
                .attr("class", "line")
                .attr("fill", "none")
                .attr("stroke", "steelblue")
                .attr("stroke-width", 3)
                .attr("d", lineGen);
  
        // Add circles
        plotArea.selectAll("circle").data(openYear)
                .join("circle")
                .attr("r", 3)
                .attr("fill", "navy")
                .attr("cx", d => yearScale(d['Year']) )
                .attr("cy", d => countScale(d['Count']) );


        //Filter out 2021 because the statistics for this year is not complete
        openYear = openYear.filter((d) => d['Year'].toString() !== "2021")

    });
</script>

<script>

    const svg2 = d3.select("svg#scatterplot");

    const width2 = svg2.attr("width");
    const height2 = svg2.attr("height");
    const margin = { top: 10, right: 10, bottom: 60, left: 80 };

    const chartWidth = width2 - margin.left - margin.right;
    const chartHeight = height2 - margin.top - margin.bottom;

    let annotations = svg2.append("g").attr("id", "annotations");
    let chartArea = svg2.append("g").attr("id", "points")
        .attr("transform", `translate(${margin.left},${margin.top})`);

    d3.csv("./ElectricCarData.csv", d3.autoType)
        .then((data) => {

            console.log(data);

            var companies = [... new Set(data.map(d => d['Brand']))];

            // scale
            const speedExtent = d3.extent(data, d => d['TopSpeed_KmH']);
            const speedScale = d3.scaleLinear().domain([0, speedExtent[1]]).range([0, chartWidth]);

            const rangeExtent = d3.extent(data, d => d['Range_Km']);
            const rangeScale = d3.scaleLinear().domain([0, rangeExtent[1]]).range([chartHeight, 0]);

            const companyScale = d3.scaleOrdinal(d3.schemeTableau10);

            // y axis
            let leftAxis = d3.axisLeft(rangeScale);
            let leftGridlines = d3.axisLeft(rangeScale)
                .tickSize(-chartWidth - 10)
                .tickFormat("")
            annotations.append("g")
                .attr("class", "y axis")
                .attr("transform", `translate(${margin.left - 10},${margin.top})`)
                .call(leftAxis)
            annotations.append("g")
                .attr("class", "y gridlines")
                .attr("transform", `translate(${margin.left - 10},${margin.top})`)
                .call(leftGridlines);

            // x axis
            let bottomAxis = d3.axisBottom(speedScale);
            let bottomGridlines = d3.axisBottom(speedScale)
                .tickSize(-chartHeight - 10)
                .tickFormat("")
                .ticks(5);
            annotations.append("g")
                .attr("class", "x axis")
                .attr("transform", `translate(${margin.left},${chartHeight + margin.top + 10})`)
                .call(bottomAxis);
            annotations.append("g")
                .attr("class", "x gridlines")
                .attr("transform", `translate(${margin.left},${chartHeight + margin.top + 10})`)
                .call(bottomGridlines);

            // circles
            chartArea.selectAll("circle").data(data)
                .join("circle")
                .attr("r", 9)
                .attr("opacity", 0.7)
                .attr("fill", d => companyScale(d['Brand']))
                .attr("cx", d => rangeScale(d['Range_Km']))
                .attr("cy", d => speedScale(d['TopSpeed_KmH']))

            // legend
            companyScale.domain().forEach(function (d, i) {
                d3.select("#scatterLegend")
                    .append("div")
                    .text(d)
                    .style("background-color", companyScale(d))
            });


        },
            (error) => { console.log(error) });





</script>

</html>